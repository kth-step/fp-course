metavar var, x, y ::=
 {{ com  term variable }}
 {{ coq nat}} {{ hol string}} {{ coq-equality }}
 {{ lex alphanum}} {{ tex \mathit{[[var]]} }}

grammar
t :: 't_' ::=                               {{ com term    }}
  | x            ::  :: Var                   {{ com variable}}
  | \ x . t      ::  :: Lam (+ bind x in t +) {{ com lambda  }}
  | t t'         ::  :: App                   {{ com app     }}
  | ( t )        :: S:: Paren                 {{ icho [[t]]  }} 
  | [ t / x ] t' :: M:: Tsub  
    {{ coq (tsubst_t [[t]] [[x]] [[t']])}}
    {{ hol (tsubst_t [[t]] [[x]] [[t']])}}

v :: 'v_' ::=                               {{ com value   }}
  | \ x . t      ::  :: Lam                   {{ com lambda  }}

typ, T :: 'typ_' ::= {{ com types }}
  | base        ::   :: base   {{ com base type }}
    {{ tex \mathsf{o} }}
  | T1 -> T2    ::   :: arrow  {{ com function types }}

ctx, G {{ tex \Gamma }} :: '' ::=
 {{ com typing context }}
 {{ coq list ( atom * typ ) }}
  | empty          ::   :: Empty {{ coq nil }}
                                 {{ tex \bullet }}
                                 {{ com empty context }}
  | G , x : T      ::   :: Cons  {{ coq (([[x]]~[[T]])++[[G]]) }}
                                 {{ com assumption }}

terminals :: 'terminals_' ::=
  | \            ::  :: lambda  {{ tex \lambda }}
  | -->          ::  :: red     {{ tex \longrightarrow }}
  | ->           ::  :: func   {{ tex \rightarrow }}
  | in           ::  :: in      {{ tex \in }}
  | <>           ::  :: neq      {{ tex \neq }}
  | =a           ::  :: aeq      {{ tex \equiv_\alpha }}
  | =b           ::  :: beq      {{ tex \equiv_\beta }}
  | FV           ::  :: FV      {{ tex \mathrm{FV} }}
  | notin            ::  :: notin {{ tex \notin }}
  | dom              ::  :: dom {{ tex \mathit{dom} }}
  | |-                  ::   :: turnstile  {{ tex \vdash }}

formula :: formula_ ::= 
  {{ com formulas }}
  | judgement :: :: judgement
  | x <> x' :: M :: var_neq
    {{ coq ([[x]] <> [[x']]) }}
    {{ hol ([[x]] <> [[x']]) }}
  | x notin FV ( t ) :: M :: notin_fv
    {{ coq (~ fv [[x]] [[t]]) }}
    {{ hol (~ fv [[x]] [[t]]) }}
  | x : T in G               :: M :: inG
  | x notin dom ( G )        :: M :: notInGx

subrules
  v <:: t

substitutions
  single t x :: tsubst 

parsing
  typ_arrow right typ_arrow

defns
red :: '' ::=

 defn
 t1 --> t2 :: :: reduce :: red_ {{ com $[[t1]]$ reduces to $[[t2]]$}} by

 -------------------------  :: ax_app
 (\x.t12) v2 --> [v2/x]t12

 t1 --> t1'
 -------------- :: ctx_app_fun
 t1 t --> t1' t

 t1 --> t1'
 -------------- :: ctx_app_arg
 v t1 --> v t1'

defns
fv :: '' ::=

 defn
 x in FV ( t ) :: :: fv :: fv_ {{ com free variable }} by
 
 ---------- :: var
 x in FV(x)

 x in FV(t1)
 -------------- :: app_l
 x in FV(t1 t2)

 x in FV(t2)
 -------------- :: app_r
 x in FV(t1 t2)

 x in FV(t)
 x <> y
 ------------- :: lam
 x in FV(\y.t)

defns
aeq :: '' ::=
 
 defn
 t =a t' :: :: aeq :: aeq_ {{ com alpha equivalence }} by

 ------ :: id
 t =a t

 t =a t'
 ------- :: sym
 t' =a t

 t =a t'
 t' =a t''
 --------- :: trans
 t =a t''

 t1 =a t1'
 t2 =a t2'
 ---------------- :: app
 t1 t2 =a t1' t2'

 t =a t'
 ------------- :: lam
 \x.t =a \x.t'

 x' notin FV(t)
 ------------------- :: subst
 \x.t =a \x'.[x'/x]t

defns
beq :: '' ::=

 defn
 t =b t' :: :: beq :: beq_ {{ com beta equivalence }} by

 ------ :: id
 t =b t

 t =b t'
 ------- :: sym
 t' =b t

 t =b t'
 t' =b t''
 --------- :: trans
 t =b t''

 t1 =b t1'
 t2 =b t2'
 --------- :: app
 t1 t2 =b t1' t2'

 t =b t'
 ------------- :: lam
 \x.t =b \x.t'

 --------------------- :: subst
 (\x.t) t' =b [t'/x] t

defns
typing :: '' ::=

defn
G |- t : T ::   :: typing :: 'typing_'
{{ com Typing rules }}
by

x : T in G
---------- :: var
G |- x : T

G, x : T1 |- t : T2
-------------------------- :: abs
G |- \x. t : T1 -> T2

G |- t1 : T1 -> T2
G |- t2 : T1
------------------ :: app
G |- t1 t2 : T2
