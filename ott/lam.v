(* generated by Ott 0.33 from: lam.ott *)

Require Import Arith.
Require Import Bool.
Require Import List.
Require Import Ott.ott_list_core.


Definition termvar : Set := nat. (*r term variable *)
Lemma eq_termvar: forall (x y : termvar), {x = y} + {x <> y}.
Proof.
  decide equality; auto with ott_coq_equality arith.
Defined.
Hint Resolve eq_termvar : ott_coq_equality.

Inductive t : Set :=  (*r term *)
 | t_Var (x:termvar) (*r variable *)
 | t_Lam (x:termvar) (t5:t) (*r lambda *)
 | t_App (t5:t) (t':t) (*r app *).

(** subrules *)
Definition is_v_of_t (t_6:t) : bool :=
  match t_6 with
  | (t_Var x) => false
  | (t_Lam x t5) => (true)
  | (t_App t5 t') => false
end.

(** library functions *)
Fixpoint list_mem A (eq:forall a b:A,{a=b}+{a<>b}) (x:A) (l:list A) {struct l} : bool :=
  match l with
  | nil => false
  | cons h t => if eq h x then true else list_mem A eq x t
end.
Arguments list_mem [A] _ _ _.


(** substitutions *)
Fixpoint tsubst_t (t_6:t) (x5:termvar) (t__7:t) {struct t__7} : t :=
  match t__7 with
  | (t_Var x) => (if eq_termvar x x5 then t_6 else (t_Var x))
  | (t_Lam x t5) => t_Lam x (if list_mem eq_termvar x5 (cons x nil) then t5 else (tsubst_t t_6 x5 t5))
  | (t_App t5 t') => t_App (tsubst_t t_6 x5 t5) (tsubst_t t_6 x5 t')
end.

(** definitions *)

(* defns red *)
Inductive reduce : t -> t -> Prop :=    (* defn reduce *)
 | red_ax_app : forall (x:termvar) (t12 v2:t),
     Is_true (is_v_of_t v2) ->
     reduce (t_App  (t_Lam x t12)  v2)  (tsubst_t  v2   x   t12 ) 
 | red_ctx_app_fun : forall (t1 t_5 t1':t),
     reduce t1 t1' ->
     reduce (t_App t1 t_5) (t_App t1' t_5)
 | red_ctx_app_arg : forall (v5 t1 t1':t),
     Is_true (is_v_of_t v5) ->
     reduce t1 t1' ->
     reduce (t_App v5 t1) (t_App v5 t1').
(** definitions *)

(* defns fv *)
Inductive fv : termvar -> t -> Prop :=    (* defn fv *)
 | fv_var : forall (x:termvar),
     fv x (t_Var x)
 | fv_app_l : forall (x:termvar) (t1 t2:t),
     fv x t1 ->
     fv x (t_App t1 t2)
 | fv_app_r : forall (x:termvar) (t1 t2:t),
     fv x t2 ->
     fv x (t_App t1 t2)
 | fv_lam : forall (x y:termvar) (t5:t),
     fv x t5 ->
      ( x  <>  y )  ->
     fv x (t_Lam y t5).
(** definitions *)

(* defns aeq *)
Inductive aeq : t -> t -> Prop :=    (* defn aeq *)
 | aeq_id : forall (t5:t),
     aeq t5 t5
 | aeq_sym : forall (t' t5:t),
     aeq t5 t' ->
     aeq t' t5
 | aeq_trans : forall (t5 t'' t':t),
     aeq t5 t' ->
     aeq t' t'' ->
     aeq t5 t''
 | aeq_app : forall (t1 t2 t1' t2':t),
     aeq t1 t1' ->
     aeq t2 t2' ->
     aeq (t_App t1 t2) (t_App t1' t2')
 | aeq_lam : forall (x:termvar) (t5 t':t),
     aeq t5 t' ->
     aeq (t_Lam x t5) (t_Lam x t')
 | aeq_subst : forall (x:termvar) (t5:t) (x':termvar),
      (~ fv  x'   t5 )  ->
     aeq (t_Lam x t5) (t_Lam x'  (tsubst_t  (t_Var x')   x   t5 ) ).
(** definitions *)

(* defns beq *)
Inductive beq : t -> t -> Prop :=    (* defn beq *)
 | beq_id : forall (t5:t),
     beq t5 t5
 | beq_sym : forall (t' t5:t),
     beq t5 t' ->
     beq t' t5
 | beq_trans : forall (t5 t'' t':t),
     beq t5 t' ->
     beq t' t'' ->
     beq t5 t''
 | beq_app : forall (t1 t2 t1' t2':t),
     beq t1 t1' ->
     beq t2 t2' ->
     beq (t_App t1 t2) (t_App t1' t2')
 | beq_lam : forall (x:termvar) (t5 t':t),
     beq t5 t' ->
     beq (t_Lam x t5) (t_Lam x t')
 | beq_subst : forall (x:termvar) (t5 t':t),
     beq (t_App  (t_Lam x t5)  t')  (tsubst_t  t'   x   t5 ) .


